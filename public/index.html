<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Etuovi Video Editor</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #fff;
      padding: 20px;
    }
    
    .container { max-width: 1200px; margin: 0 auto; }
    
    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5rem;
      background: linear-gradient(90deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .subtitle { text-align: center; color: #888; margin-bottom: 30px; }
    
    .input-section {
      display: flex;
      gap: 10px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    input[type="text"], input[type="number"], select {
      padding: 15px 20px;
      border: none;
      border-radius: 10px;
      background: rgba(255,255,255,0.1);
      color: #fff;
      font-size: 16px;
    }
    
    input[type="text"] { flex: 1; min-width: 300px; max-width: 600px; }
    input[type="text"]::placeholder { color: #666; }
    
    button {
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(90deg, #667eea, #764ba2);
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s, opacity 0.2s;
    }
    
    button:hover { transform: translateY(-2px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    
    .status {
      text-align: center;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 10px;
      background: rgba(255,255,255,0.05);
    }
    
    .status.error { background: rgba(255,0,0,0.2); }
    
    .progress-bar {
      width: 100%;
      height: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 5px;
      overflow: hidden;
      margin-top: 10px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      transition: width 0.3s;
    }
    
    .main-content { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
    @media (max-width: 900px) { .main-content { grid-template-columns: 1fr; } }
    
    .panel {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 20px;
    }
    
    .panel h2 { margin-bottom: 15px; font-size: 1.2rem; color: #aaa; }
    
    .preview-container {
      position: relative;
      width: 100%;
      aspect-ratio: 9/16;
      max-height: 70vh;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      margin: 0 auto;
    }
    
    #preview-canvas { width: 100%; height: 100%; object-fit: contain; }
    
    .property-info {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
    }
    
    .property-info h3 { font-size: 1.1rem; margin-bottom: 5px; }
    .property-info p { color: #888; font-size: 0.9rem; }
    
    .settings {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .settings label {
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-size: 0.85rem;
      color: #aaa;
    }
    
    .images-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .images-grid img {
      width: 100%;
      aspect-ratio: 1;
      object-fit: cover;
      border-radius: 5px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    
    .images-grid img:hover, .images-grid img.selected { opacity: 1; }
    
    .controls { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 20px; }
    .controls button { flex: 1; min-width: 120px; }
    
    #download-btn { background: linear-gradient(90deg, #11998e, #38ef7d); }
    .hidden { display: none !important; }
    
    .beat-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #667eea;
      opacity: 0;
      transition: opacity 0.1s;
    }
    
    .beat-indicator.pulse { opacity: 1; }
    
    .story-arc {
      margin-top: 15px;
      padding: 10px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
    }
    
    .story-arc h3 { font-size: 0.9rem; color: #aaa; margin-bottom: 10px; }
    
    .story-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      margin-bottom: 5px;
      background: rgba(255,255,255,0.03);
      border-radius: 5px;
      font-size: 0.85rem;
    }
    
    .story-item img {
      width: 40px;
      height: 40px;
      object-fit: cover;
      border-radius: 4px;
    }
    
    .story-item .caption { color: #ccc; flex: 1; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üè† Etuovi Video Editor</h1>
    <p class="subtitle">Create social media videos from Finnish property listings</p>
    
    <div class="input-section">
      <input type="text" id="url-input" placeholder="Paste Etuovi URL (e.g., https://www.etuovi.com/kohde/12345678)">
      <button id="fetch-btn" onclick="fetchListing()">Fetch Listing</button>
    </div>
    
    <div id="status" class="status hidden">
      <p id="status-text">Loading...</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
      </div>
    </div>
    
    <div id="editor" class="main-content hidden">
      <div class="panel">
        <h2>Preview</h2>
        <div class="preview-container">
          <canvas id="preview-canvas" width="1080" height="1920"></canvas>
          <div class="beat-indicator" id="beat-indicator"></div>
        </div>
        <div class="controls">
          <button id="play-btn" onclick="togglePreview()">‚ñ∂ Preview</button>
          <button id="generate-btn" onclick="generateVideo()">üé¨ Generate Video</button>
          <button id="download-btn" class="hidden" onclick="downloadVideo()">‚¨á Download</button>
        </div>
      </div>
      
      <div class="panel">
        <h2>Property Info</h2>
        <div class="property-info">
          <h3 id="property-title">-</h3>
          <p id="property-details">-</p>
        </div>
        
        <h2>Settings</h2>
        <div class="settings">
          <label>
            BPM
            <input type="number" id="bpm-input" value="120" min="60" max="180">
          </label>
          <label>
            Duration (s)
            <input type="number" id="duration-input" value="20" min="10" max="60">
          </label>
          <label>
            Transition
            <select id="transition-style">
              <option value="cut">Hard Cut</option>
              <option value="fade" selected>Crossfade</option>
              <option value="zoom">Zoom Punch</option>
              <option value="slide">Slide</option>
            </select>
          </label>
          <label>
            Beats/Image
            <select id="beats-per-image">
              <option value="2">2 (fast)</option>
              <option value="4" selected>4 (normal)</option>
              <option value="8">8 (slow)</option>
            </select>
          </label>
        </div>
        
        <div class="story-arc" id="story-arc">
          <h3>üìñ Story Arc (10 best images)</h3>
          <div id="story-items"></div>
        </div>
        
        <h2>All Images (<span id="image-count">0</span>)</h2>
        <div class="images-grid" id="images-grid"></div>
      </div>
    </div>
  </div>
  
  <audio id="bg-music" loop crossorigin="anonymous">
    <source src="https://cdn.pixabay.com/download/audio/2022/05/27/audio_1808fbf07a.mp3" type="audio/mpeg">
  </audio>
  
  <script>
    let allImages = [];
    let storyImages = [];
    let propertyData = null;
    let isPlaying = false;
    let animationId = null;
    let currentFrame = 0;
    let videoBlob = null;
    let audioContext = null;
    
    const canvas = document.getElementById('preview-canvas');
    const ctx = canvas.getContext('2d');
    const bgMusic = document.getElementById('bg-music');
    const beatIndicator = document.getElementById('beat-indicator');
    
    const VIDEO_WIDTH = 1080;
    const VIDEO_HEIGHT = 1920;
    const FPS = 30;
    const MIN_CLIP_DURATION = 1.0;
    
    // Story arc structure - typical real estate video flow
    const STORY_STRUCTURE = [
      { type: 'exterior', caption: 'Tervetuloa kotiin! üè†', fallback: 'intro' },
      { type: 'highlight', caption: null, fallback: 'price' },
      { type: 'livingRoom', caption: null, fallback: 'Viihtyis√§ olohuone üõãÔ∏è' },
      { type: 'kitchen', caption: null, fallback: 'Kodin syd√§n üçΩÔ∏è' },
      { type: 'bedroom', caption: null, fallback: 'Rauhallinen makuuhuone üò¥' },
      { type: 'bathroom', caption: null, fallback: 'Toimiva kylpyhuone üöø' },
      { type: 'sauna', caption: null, fallback: 'Oma sauna üßñ' },
      { type: 'detail', caption: 'Laadukkaita yksityiskohtia ‚ú®', fallback: null },
      { type: 'yard', caption: 'Oma piha üåø', fallback: null },
      { type: 'exterior', caption: null, fallback: 'closing' }
    ];
    
    function getSettings() {
      return {
        bpm: parseInt(document.getElementById('bpm-input').value) || 120,
        duration: parseInt(document.getElementById('duration-input').value) || 20,
        transitionStyle: document.getElementById('transition-style').value,
        beatsPerImage: parseInt(document.getElementById('beats-per-image').value) || 4
      };
    }
    
    function getImageSchedule() {
      const settings = getSettings();
      const beatInterval = 60 / settings.bpm;
      const clipDuration = Math.max(MIN_CLIP_DURATION, beatInterval * settings.beatsPerImage);
      
      const schedule = [];
      let currentTime = 0;
      let imageIndex = 0;
      
      while (currentTime < settings.duration && imageIndex < storyImages.length) {
        schedule.push({
          imageIndex: imageIndex,
          startTime: currentTime,
          endTime: Math.min(currentTime + clipDuration, settings.duration),
          duration: clipDuration,
          caption: storyImages[imageIndex]?.caption || ''
        });
        currentTime += clipDuration;
        imageIndex++;
      }
      
      // Loop if needed
      while (currentTime < settings.duration) {
        schedule.push({
          imageIndex: imageIndex % storyImages.length,
          startTime: currentTime,
          endTime: Math.min(currentTime + clipDuration, settings.duration),
          duration: clipDuration,
          caption: storyImages[imageIndex % storyImages.length]?.caption || ''
        });
        currentTime += clipDuration;
        imageIndex++;
      }
      
      return schedule;
    }
    
    function getBeatInfo(time) {
      const settings = getSettings();
      const beatInterval = 60 / settings.bpm;
      const currentBeat = time / beatInterval;
      const beatProgress = currentBeat % 1;
      const isOnBeat = beatProgress < 0.1 || beatProgress > 0.9;
      
      return { beatNumber: Math.floor(currentBeat), beatProgress, isOnBeat, beatInterval };
    }
    
    async function fetchListing() {
      const url = document.getElementById('url-input').value.trim();
      if (!url) {
        showStatus('Please enter an Etuovi URL', true);
        return;
      }
      
      showStatus('Fetching listing...', false);
      document.getElementById('fetch-btn').disabled = true;
      
      try {
        const response = await fetch('/api/scrape', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        
        const data = await response.json();
        
        if (!response.ok) throw new Error(data.error || 'Failed to fetch listing');
        if (data.images.length === 0) throw new Error('No images found in listing');
        
        propertyData = data;
        
        document.getElementById('property-title').textContent = data.address || data.title;
        document.getElementById('property-details').textContent = 
          [data.price, data.size, data.year ? `Built ${data.year}` : ''].filter(Boolean).join(' ‚Ä¢ ');
        
        await loadImages(data.images);
        buildStoryArc(data);
        
        hideStatus();
        document.getElementById('editor').classList.remove('hidden');
        drawFrame(0);
        
      } catch (error) {
        showStatus(error.message, true);
      } finally {
        document.getElementById('fetch-btn').disabled = false;
      }
    }
    
    async function loadImages(imageUrls) {
      showStatus('Loading images...', false);
      
      const grid = document.getElementById('images-grid');
      grid.innerHTML = '';
      
      allImages = [];
      const maxImages = 20;
      const urlsToLoad = imageUrls.slice(0, maxImages);
      
      for (let i = 0; i < urlsToLoad.length; i++) {
        const progress = ((i + 1) / urlsToLoad.length) * 100;
        setProgress(progress);
        
        try {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = `/api/proxy?url=${encodeURIComponent(urlsToLoad[i])}`;
          });
          
          allImages.push({ img, url: urlsToLoad[i], index: i });
          
          const thumb = document.createElement('img');
          thumb.src = img.src;
          thumb.className = 'selected';
          grid.appendChild(thumb);
          
        } catch (e) {
          console.error('Failed to load image:', urlsToLoad[i]);
        }
      }
      
      document.getElementById('image-count').textContent = allImages.length;
      setProgress(100);
    }
    
    function buildStoryArc(data) {
      // Select best images for story arc (max 10)
      const selectedImages = [];
      const captions = data.roomCaptions || {};
      const tags = data.imageTags || [];
      
      // Build story based on available images and captions
      const storyOrder = [
        { tag: 'julkisivu', caption: captions.exterior || 'Tervetuloa! üè†', type: 'intro' },
        { tag: null, caption: `${data.price} ‚Ä¢ ${data.size}`, type: 'highlight' },
        { tag: 'olohuone', caption: captions.livingRoom || 'Viihtyis√§ olohuone üõãÔ∏è', type: 'room' },
        { tag: 'keitti√∂', caption: captions.kitchen || 'Kodin syd√§n üçΩÔ∏è', type: 'room' },
        { tag: 'makuuhuone', caption: captions.bedroom || 'Rauhallinen makuuhuone üò¥', type: 'room' },
        { tag: 'kylpyhuone', caption: captions.bathroom || 'Toimiva kylpyhuone üöø', type: 'room' },
        { tag: 'sauna', caption: captions.sauna || 'Oma sauna üßñ', type: 'room' },
        { tag: 'piha', caption: 'Oma piha üåø', type: 'exterior' },
        { tag: null, caption: 'Laadukkaita yksityiskohtia ‚ú®', type: 'detail' },
        { tag: 'julkisivu', caption: data.address?.split(',')[0] || 'üè†', type: 'closing' }
      ];
      
      const usedIndices = new Set();
      
      // First pass: match by tags if available
      for (const story of storyOrder) {
        let found = false;
        
        // Try to find matching tag
        if (story.tag && tags.length > 0) {
          for (let i = 0; i < tags.length && i < allImages.length; i++) {
            if (!usedIndices.has(i) && tags[i] && tags[i].toLowerCase().includes(story.tag)) {
              selectedImages.push({
                ...allImages[i],
                caption: story.caption
              });
              usedIndices.add(i);
              found = true;
              break;
            }
          }
        }
        
        // If no tag match, use next available image
        if (!found) {
          for (let i = 0; i < allImages.length; i++) {
            if (!usedIndices.has(i)) {
              selectedImages.push({
                ...allImages[i],
                caption: story.caption
              });
              usedIndices.add(i);
              break;
            }
          }
        }
      }
      
      // Limit to 10 images
      storyImages = selectedImages.slice(0, 10);
      
      // Update story arc UI
      const storyContainer = document.getElementById('story-items');
      storyContainer.innerHTML = '';
      
      storyImages.forEach((item, i) => {
        const div = document.createElement('div');
        div.className = 'story-item';
        div.innerHTML = `
          <img src="${item.img.src}" alt="Scene ${i + 1}">
          <span class="caption">${i + 1}. ${item.caption}</span>
        `;
        storyContainer.appendChild(div);
      });
    }
    
    function drawFrame(frameNum) {
      const settings = getSettings();
      const totalFrames = settings.duration * FPS;
      const currentTime = frameNum / FPS;
      
      const schedule = getImageSchedule();
      const beatInfo = getBeatInfo(currentTime);
      
      let currentClip = schedule[0];
      let nextClip = schedule[1];
      
      for (let i = 0; i < schedule.length; i++) {
        if (currentTime >= schedule[i].startTime && currentTime < schedule[i].endTime) {
          currentClip = schedule[i];
          nextClip = schedule[i + 1] || schedule[0];
          break;
        }
      }
      
      const clipProgress = (currentTime - currentClip.startTime) / currentClip.duration;
      const imgData = storyImages[currentClip.imageIndex];
      const nextImgData = storyImages[nextClip.imageIndex];
      
      if (!imgData?.img) return;
      
      const img = imgData.img;
      const nextImg = nextImgData?.img;
      
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
      
      const transitionDuration = 0.2;
      const transitionStart = 1 - (transitionDuration / currentClip.duration);
      const inTransition = clipProgress > transitionStart;
      const transitionProgress = inTransition ? (clipProgress - transitionStart) / (1 - transitionStart) : 0;
      
      const baseZoom = 1.15;
      const zoomRange = 0.1;
      const zoom = baseZoom + Math.sin(clipProgress * Math.PI) * zoomRange;
      const beatPulse = beatInfo.isOnBeat ? 1.02 : 1;
      const finalZoom = zoom * beatPulse;
      
      const panDirection = currentClip.imageIndex % 2 === 0 ? 1 : -1;
      const panAmount = (clipProgress - 0.5) * 80 * panDirection;
      
      if (inTransition && nextImg && settings.transitionStyle !== 'cut') {
        drawTransition(img, nextImg, transitionProgress, finalZoom, panAmount, settings.transitionStyle);
      } else {
        drawImage(img, finalZoom, panAmount, 1);
      }
      
      // Vignette
      const gradient = ctx.createRadialGradient(
        VIDEO_WIDTH / 2, VIDEO_HEIGHT / 2, VIDEO_HEIGHT * 0.3,
        VIDEO_WIDTH / 2, VIDEO_HEIGHT / 2, VIDEO_HEIGHT * 0.8
      );
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, 'rgba(0,0,0,0.4)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
      
      // Draw caption overlay
      drawCaptionOverlay(currentClip.caption, clipProgress);
      
      // Draw property info at bottom
      drawPropertyOverlay();
      
      if (beatInfo.isOnBeat) {
        beatIndicator.classList.add('pulse');
        setTimeout(() => beatIndicator.classList.remove('pulse'), 100);
      }
    }
    
    function drawImage(img, zoom, panX, alpha) {
      ctx.globalAlpha = alpha;
      
      const imgRatio = img.width / img.height;
      const canvasRatio = VIDEO_WIDTH / VIDEO_HEIGHT;
      
      let drawWidth, drawHeight;
      if (imgRatio > canvasRatio) {
        drawHeight = VIDEO_HEIGHT * zoom;
        drawWidth = drawHeight * imgRatio;
      } else {
        drawWidth = VIDEO_WIDTH * zoom;
        drawHeight = drawWidth / imgRatio;
      }
      
      const x = (VIDEO_WIDTH - drawWidth) / 2 + panX;
      const y = (VIDEO_HEIGHT - drawHeight) / 2;
      
      ctx.drawImage(img, x, y, drawWidth, drawHeight);
      ctx.globalAlpha = 1;
    }
    
    function drawTransition(img1, img2, progress, zoom, panX, style) {
      switch (style) {
        case 'fade':
          drawImage(img1, zoom, panX, 1 - progress);
          drawImage(img2, 1.15, 0, progress);
          break;
        case 'zoom':
          const zoomOut = zoom * (1 + progress * 0.3);
          const zoomIn = 1.3 - progress * 0.15;
          drawImage(img1, zoomOut, panX, 1 - progress);
          drawImage(img2, zoomIn, 0, progress);
          break;
        case 'slide':
          const slideOffset = progress * VIDEO_WIDTH;
          ctx.save();
          ctx.translate(-slideOffset, 0);
          drawImage(img1, zoom, panX, 1);
          ctx.restore();
          ctx.save();
          ctx.translate(VIDEO_WIDTH - slideOffset, 0);
          drawImage(img2, 1.15, 0, 1);
          ctx.restore();
          break;
        default:
          drawImage(img1, zoom, panX, 1);
      }
    }
    
    function drawCaptionOverlay(caption, progress) {
      if (!caption) return;
      
      // Animate caption in/out
      let opacity = 1;
      if (progress < 0.15) {
        opacity = progress / 0.15;
      } else if (progress > 0.85) {
        opacity = (1 - progress) / 0.15;
      }
      
      // Draw caption background
      ctx.fillStyle = `rgba(0,0,0,${0.6 * opacity})`;
      const captionY = VIDEO_HEIGHT * 0.4;
      const padding = 30;
      
      ctx.font = 'bold 56px -apple-system, sans-serif';
      const textWidth = ctx.measureText(caption).width;
      
      // Rounded rectangle background
      const rectX = (VIDEO_WIDTH - textWidth) / 2 - padding;
      const rectY = captionY - 45;
      const rectWidth = textWidth + padding * 2;
      const rectHeight = 80;
      
      ctx.beginPath();
      ctx.roundRect(rectX, rectY, rectWidth, rectHeight, 15);
      ctx.fill();
      
      // Draw text
      ctx.fillStyle = `rgba(255,255,255,${opacity})`;
      ctx.textAlign = 'center';
      ctx.fillText(caption, VIDEO_WIDTH / 2, captionY);
    }
    
    function drawPropertyOverlay() {
      if (!propertyData) return;
      
      const overlayHeight = 200;
      const overlayGradient = ctx.createLinearGradient(0, VIDEO_HEIGHT - overlayHeight, 0, VIDEO_HEIGHT);
      overlayGradient.addColorStop(0, 'rgba(0,0,0,0)');
      overlayGradient.addColorStop(0.5, 'rgba(0,0,0,0.7)');
      overlayGradient.addColorStop(1, 'rgba(0,0,0,0.9)');
      ctx.fillStyle = overlayGradient;
      ctx.fillRect(0, VIDEO_HEIGHT - overlayHeight, VIDEO_WIDTH, overlayHeight);
      
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 48px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      const address = propertyData.address || 'Beautiful Property';
      ctx.fillText(address.substring(0, 30), VIDEO_WIDTH / 2, VIDEO_HEIGHT - 100);
      
      ctx.font = '36px -apple-system, sans-serif';
      ctx.fillStyle = '#ccc';
      const details = [propertyData.price, propertyData.size].filter(Boolean).join(' ‚Ä¢ ');
      ctx.fillText(details, VIDEO_WIDTH / 2, VIDEO_HEIGHT - 50);
    }
    
    function togglePreview() {
      if (isPlaying) stopPreview();
      else startPreview();
    }
    
    function startPreview() {
      if (storyImages.length === 0) return;
      
      const settings = getSettings();
      const totalFrames = settings.duration * FPS;
      
      isPlaying = true;
      currentFrame = 0;
      document.getElementById('play-btn').textContent = '‚è∏ Pause';
      bgMusic.currentTime = 0;
      bgMusic.volume = 0.3;
      bgMusic.play().catch(() => {});
      
      let lastTime = 0;
      const frameInterval = 1000 / FPS;
      
      function animateThrottled(timestamp) {
        if (!isPlaying) return;
        
        const delta = timestamp - lastTime;
        if (delta >= frameInterval) {
          lastTime = timestamp - (delta % frameInterval);
          drawFrame(currentFrame);
          currentFrame = (currentFrame + 1) % totalFrames;
        }
        
        animationId = requestAnimationFrame(animateThrottled);
      }
      
      animationId = requestAnimationFrame(animateThrottled);
    }
    
    function stopPreview() {
      isPlaying = false;
      document.getElementById('play-btn').textContent = '‚ñ∂ Preview';
      bgMusic.pause();
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }
    
    async function generateVideo() {
      if (storyImages.length === 0) {
        showStatus('No images loaded', true);
        return;
      }
      
      const settings = getSettings();
      const totalFrames = settings.duration * FPS;
      
      stopPreview();
      showStatus('Generating video... This may take a minute.', false);
      document.getElementById('generate-btn').disabled = true;
      
      try {
        const stream = canvas.captureStream(FPS);
        
        if (!audioContext) audioContext = new AudioContext();
        
        const audioSource = audioContext.createMediaElementSource(bgMusic);
        const audioDestination = audioContext.createMediaStreamDestination();
        audioSource.connect(audioDestination);
        audioSource.connect(audioContext.destination);
        
        const combinedStream = new MediaStream([
          ...stream.getVideoTracks(),
          ...audioDestination.stream.getAudioTracks()
        ]);
        
        const mediaRecorder = new MediaRecorder(combinedStream, {
          mimeType: 'video/webm;codecs=vp9',
          videoBitsPerSecond: 8000000
        });
        
        const chunks = [];
        mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
        
        mediaRecorder.onstop = () => {
          videoBlob = new Blob(chunks, { type: 'video/webm' });
          hideStatus();
          document.getElementById('download-btn').classList.remove('hidden');
          document.getElementById('generate-btn').disabled = false;
          showStatus('Video ready! Click Download to save.', false);
          bgMusic.pause();
          audioSource.disconnect();
        };
        
        mediaRecorder.start();
        bgMusic.currentTime = 0;
        bgMusic.volume = 0.5;
        bgMusic.play();
        
        let frame = 0;
        const renderInterval = setInterval(() => {
          if (frame >= totalFrames) {
            clearInterval(renderInterval);
            mediaRecorder.stop();
            return;
          }
          
          drawFrame(frame);
          frame++;
          setProgress((frame / totalFrames) * 100);
        }, 1000 / FPS);
        
      } catch (error) {
        console.error('Video generation error:', error);
        showStatus('Video generation failed. Try using Chrome browser.', true);
        document.getElementById('generate-btn').disabled = false;
      }
    }
    
    function downloadVideo() {
      if (!videoBlob) return;
      
      const url = URL.createObjectURL(videoBlob);
      const a = document.createElement('a');
      a.href = url;
      const address = propertyData?.address?.replace(/[^a-zA-Z0-9]/g, '-') || 'property';
      a.download = `etuovi-${address.substring(0, 30)}-${Date.now()}.webm`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function showStatus(text, isError) {
      const status = document.getElementById('status');
      status.classList.remove('hidden');
      status.classList.toggle('error', isError);
      document.getElementById('status-text').textContent = text;
    }
    
    function hideStatus() { document.getElementById('status').classList.add('hidden'); }
    function setProgress(percent) { document.getElementById('progress-fill').style.width = percent + '%'; }
    
    // Update on settings change
    ['bpm-input', 'duration-input', 'beats-per-image'].forEach(id => {
      document.getElementById(id).addEventListener('change', () => {
        if (storyImages.length > 0) drawFrame(currentFrame);
      });
    });
  </script>
</body>
</html>
