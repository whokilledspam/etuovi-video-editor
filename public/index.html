<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Etuovi Video Editor</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #fff;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5rem;
      background: linear-gradient(90deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 30px;
    }
    
    .input-section {
      display: flex;
      gap: 10px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    input[type="text"], input[type="number"], select {
      padding: 15px 20px;
      border: none;
      border-radius: 10px;
      background: rgba(255,255,255,0.1);
      color: #fff;
      font-size: 16px;
    }
    
    input[type="text"] {
      flex: 1;
      min-width: 300px;
      max-width: 600px;
    }
    
    input[type="text"]::placeholder {
      color: #666;
    }
    
    button {
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(90deg, #667eea, #764ba2);
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s, opacity 0.2s;
    }
    
    button:hover {
      transform: translateY(-2px);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .status {
      text-align: center;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 10px;
      background: rgba(255,255,255,0.05);
    }
    
    .status.error {
      background: rgba(255,0,0,0.2);
    }
    
    .progress-bar {
      width: 100%;
      height: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 5px;
      overflow: hidden;
      margin-top: 10px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      transition: width 0.3s;
    }
    
    .main-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
    }
    
    @media (max-width: 900px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }
    
    .panel {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 20px;
    }
    
    .panel h2 {
      margin-bottom: 15px;
      font-size: 1.2rem;
      color: #aaa;
    }
    
    .preview-container {
      position: relative;
      width: 100%;
      aspect-ratio: 9/16;
      max-height: 70vh;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      margin: 0 auto;
    }
    
    #preview-canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    .property-info {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
    }
    
    .property-info h3 {
      font-size: 1.1rem;
      margin-bottom: 5px;
    }
    
    .property-info p {
      color: #888;
      font-size: 0.9rem;
    }
    
    .settings {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .settings label {
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-size: 0.85rem;
      color: #aaa;
    }
    
    .images-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .images-grid img {
      width: 100%;
      aspect-ratio: 1;
      object-fit: cover;
      border-radius: 5px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    
    .images-grid img:hover,
    .images-grid img.selected {
      opacity: 1;
    }
    
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 20px;
    }
    
    .controls button {
      flex: 1;
      min-width: 120px;
    }
    
    #download-btn {
      background: linear-gradient(90deg, #11998e, #38ef7d);
    }
    
    .hidden {
      display: none !important;
    }

    .beat-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #667eea;
      opacity: 0;
      transition: opacity 0.1s;
    }
    
    .beat-indicator.pulse {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üè† Etuovi Video Editor</h1>
    <p class="subtitle">Create social media videos from Finnish property listings</p>
    
    <div class="input-section">
      <input type="text" id="url-input" placeholder="Paste Etuovi URL (e.g., https://www.etuovi.com/kohde/12345678)">
      <button id="fetch-btn" onclick="fetchListing()">Fetch Listing</button>
    </div>
    
    <div id="status" class="status hidden">
      <p id="status-text">Loading...</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
      </div>
    </div>
    
    <div id="editor" class="main-content hidden">
      <div class="panel">
        <h2>Preview</h2>
        <div class="preview-container">
          <canvas id="preview-canvas" width="1080" height="1920"></canvas>
          <div class="beat-indicator" id="beat-indicator"></div>
        </div>
        <div class="controls">
          <button id="play-btn" onclick="togglePreview()">‚ñ∂ Preview</button>
          <button id="generate-btn" onclick="generateVideo()">üé¨ Generate Video</button>
          <button id="download-btn" class="hidden" onclick="downloadVideo()">‚¨á Download</button>
        </div>
      </div>
      
      <div class="panel">
        <h2>Property Info</h2>
        <div class="property-info">
          <h3 id="property-title">-</h3>
          <p id="property-details">-</p>
        </div>
        
        <h2>Settings</h2>
        <div class="settings">
          <label>
            BPM (Beats Per Minute)
            <input type="number" id="bpm-input" value="120" min="60" max="180">
          </label>
          <label>
            Video Duration (seconds)
            <input type="number" id="duration-input" value="20" min="10" max="60">
          </label>
          <label>
            Transition Style
            <select id="transition-style">
              <option value="cut">Hard Cut</option>
              <option value="fade" selected>Crossfade</option>
              <option value="zoom">Zoom Punch</option>
              <option value="slide">Slide</option>
            </select>
          </label>
          <label>
            Beats per Image
            <select id="beats-per-image">
              <option value="2">2 beats (fast)</option>
              <option value="4" selected>4 beats (normal)</option>
              <option value="8">8 beats (slow)</option>
            </select>
          </label>
        </div>
        
        <h2>Images (<span id="image-count">0</span>)</h2>
        <div class="images-grid" id="images-grid"></div>
      </div>
    </div>
  </div>
  
  <!-- Hidden audio for background music -->
  <audio id="bg-music" loop crossorigin="anonymous">
    <source src="https://cdn.pixabay.com/download/audio/2022/05/27/audio_1808fbf07a.mp3" type="audio/mpeg">
  </audio>
  
  <script>
    let images = [];
    let propertyData = null;
    let isPlaying = false;
    let animationId = null;
    let currentFrame = 0;
    let videoBlob = null;
    let beatTimes = [];
    let audioContext = null;
    let analyser = null;
    
    const canvas = document.getElementById('preview-canvas');
    const ctx = canvas.getContext('2d');
    const bgMusic = document.getElementById('bg-music');
    const beatIndicator = document.getElementById('beat-indicator');
    
    // Video settings
    const VIDEO_WIDTH = 1080;
    const VIDEO_HEIGHT = 1920;
    const FPS = 30;
    const MIN_CLIP_DURATION = 1.0; // Minimum 1 second per clip
    
    // Get settings from UI
    function getSettings() {
      return {
        bpm: parseInt(document.getElementById('bpm-input').value) || 120,
        duration: parseInt(document.getElementById('duration-input').value) || 20,
        transitionStyle: document.getElementById('transition-style').value,
        beatsPerImage: parseInt(document.getElementById('beats-per-image').value) || 4
      };
    }
    
    // Calculate beat times based on BPM
    function calculateBeatTimes() {
      const settings = getSettings();
      const beatInterval = 60 / settings.bpm; // seconds per beat
      const totalBeats = Math.floor(settings.duration / beatInterval);
      
      beatTimes = [];
      for (let i = 0; i < totalBeats; i++) {
        beatTimes.push(i * beatInterval);
      }
      return beatTimes;
    }
    
    // Get image schedule based on beats (minimum 1s per clip)
    function getImageSchedule() {
      const settings = getSettings();
      const beatInterval = 60 / settings.bpm;
      const clipDuration = Math.max(MIN_CLIP_DURATION, beatInterval * settings.beatsPerImage);
      
      const schedule = [];
      let currentTime = 0;
      let imageIndex = 0;
      
      while (currentTime < settings.duration && imageIndex < images.length) {
        schedule.push({
          imageIndex: imageIndex,
          startTime: currentTime,
          endTime: Math.min(currentTime + clipDuration, settings.duration),
          duration: clipDuration
        });
        currentTime += clipDuration;
        imageIndex++;
      }
      
      // If we ran out of images, loop them
      while (currentTime < settings.duration) {
        schedule.push({
          imageIndex: imageIndex % images.length,
          startTime: currentTime,
          endTime: Math.min(currentTime + clipDuration, settings.duration),
          duration: clipDuration
        });
        currentTime += clipDuration;
        imageIndex++;
      }
      
      return schedule;
    }
    
    // Get current beat info for a given time
    function getBeatInfo(time) {
      const settings = getSettings();
      const beatInterval = 60 / settings.bpm;
      const currentBeat = time / beatInterval;
      const beatProgress = currentBeat % 1;
      const isOnBeat = beatProgress < 0.1 || beatProgress > 0.9;
      
      return {
        beatNumber: Math.floor(currentBeat),
        beatProgress,
        isOnBeat,
        beatInterval
      };
    }
    
    async function fetchListing() {
      const url = document.getElementById('url-input').value.trim();
      if (!url) {
        showStatus('Please enter an Etuovi URL', true);
        return;
      }
      
      showStatus('Fetching listing...', false);
      document.getElementById('fetch-btn').disabled = true;
      
      try {
        const response = await fetch('/api/scrape', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        
        const data = await response.json();
        
        if (!response.ok) {
          throw new Error(data.error || 'Failed to fetch listing');
        }
        
        if (data.images.length === 0) {
          throw new Error('No images found in listing');
        }
        
        propertyData = data;
        
        // Update UI
        document.getElementById('property-title').textContent = data.address || data.title;
        document.getElementById('property-details').textContent = 
          [data.price, data.size].filter(Boolean).join(' ‚Ä¢ ') || 'Property details';
        
        // Load and display images
        await loadImages(data.images);
        
        hideStatus();
        document.getElementById('editor').classList.remove('hidden');
        
        // Draw first frame
        drawFrame(0);
        
      } catch (error) {
        showStatus(error.message, true);
      } finally {
        document.getElementById('fetch-btn').disabled = false;
      }
    }
    
    async function loadImages(imageUrls) {
      showStatus('Loading images...', false);
      
      const grid = document.getElementById('images-grid');
      grid.innerHTML = '';
      
      images = [];
      const maxImages = 15; // Limit for performance
      const urlsToLoad = imageUrls.slice(0, maxImages);
      
      for (let i = 0; i < urlsToLoad.length; i++) {
        const progress = ((i + 1) / urlsToLoad.length) * 100;
        setProgress(progress);
        
        try {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = `/api/proxy?url=${encodeURIComponent(urlsToLoad[i])}`;
          });
          
          images.push(img);
          
          // Add thumbnail to grid
          const thumb = document.createElement('img');
          thumb.src = img.src;
          thumb.className = 'selected';
          grid.appendChild(thumb);
          
        } catch (e) {
          console.error('Failed to load image:', urlsToLoad[i]);
        }
      }
      
      document.getElementById('image-count').textContent = images.length;
      setProgress(100);
    }
    
    function drawFrame(frameNum) {
      const settings = getSettings();
      const totalFrames = settings.duration * FPS;
      const currentTime = frameNum / FPS;
      
      const schedule = getImageSchedule();
      const beatInfo = getBeatInfo(currentTime);
      
      // Find current clip
      let currentClip = schedule[0];
      let nextClip = schedule[1];
      
      for (let i = 0; i < schedule.length; i++) {
        if (currentTime >= schedule[i].startTime && currentTime < schedule[i].endTime) {
          currentClip = schedule[i];
          nextClip = schedule[i + 1] || schedule[0];
          break;
        }
      }
      
      const clipProgress = (currentTime - currentClip.startTime) / currentClip.duration;
      const img = images[currentClip.imageIndex];
      const nextImg = images[nextClip.imageIndex];
      
      if (!img) return;
      
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
      
      // Transition effects
      const transitionDuration = 0.2; // seconds
      const transitionStart = 1 - (transitionDuration / currentClip.duration);
      const inTransition = clipProgress > transitionStart;
      const transitionProgress = inTransition ? (clipProgress - transitionStart) / (1 - transitionStart) : 0;
      
      // Ken Burns effect - subtle zoom and pan
      const baseZoom = 1.15;
      const zoomRange = 0.1;
      const zoom = baseZoom + Math.sin(clipProgress * Math.PI) * zoomRange;
      
      // Beat-synced pulse effect
      const beatPulse = beatInfo.isOnBeat ? 1.02 : 1;
      const finalZoom = zoom * beatPulse;
      
      // Pan direction alternates per image
      const panDirection = currentClip.imageIndex % 2 === 0 ? 1 : -1;
      const panAmount = (clipProgress - 0.5) * 80 * panDirection;
      
      // Draw based on transition style
      if (inTransition && nextImg && settings.transitionStyle !== 'cut') {
        drawTransition(img, nextImg, transitionProgress, finalZoom, panAmount, settings.transitionStyle);
      } else {
        drawImage(img, finalZoom, panAmount, 1);
      }
      
      // Add subtle vignette
      const gradient = ctx.createRadialGradient(
        VIDEO_WIDTH / 2, VIDEO_HEIGHT / 2, VIDEO_HEIGHT * 0.3,
        VIDEO_WIDTH / 2, VIDEO_HEIGHT / 2, VIDEO_HEIGHT * 0.8
      );
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, 'rgba(0,0,0,0.4)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
      
      // Add property info overlay at bottom
      if (propertyData) {
        drawOverlay();
      }
      
      // Update beat indicator
      if (beatInfo.isOnBeat) {
        beatIndicator.classList.add('pulse');
        setTimeout(() => beatIndicator.classList.remove('pulse'), 100);
      }
    }
    
    function drawImage(img, zoom, panX, alpha) {
      ctx.globalAlpha = alpha;
      
      // Calculate dimensions to cover the canvas (crop to 9:16)
      const imgRatio = img.width / img.height;
      const canvasRatio = VIDEO_WIDTH / VIDEO_HEIGHT;
      
      let drawWidth, drawHeight;
      if (imgRatio > canvasRatio) {
        drawHeight = VIDEO_HEIGHT * zoom;
        drawWidth = drawHeight * imgRatio;
      } else {
        drawWidth = VIDEO_WIDTH * zoom;
        drawHeight = drawWidth / imgRatio;
      }
      
      const x = (VIDEO_WIDTH - drawWidth) / 2 + panX;
      const y = (VIDEO_HEIGHT - drawHeight) / 2;
      
      ctx.drawImage(img, x, y, drawWidth, drawHeight);
      ctx.globalAlpha = 1;
    }
    
    function drawTransition(img1, img2, progress, zoom, panX, style) {
      switch (style) {
        case 'fade':
          // Crossfade
          drawImage(img1, zoom, panX, 1 - progress);
          drawImage(img2, 1.15, 0, progress);
          break;
          
        case 'zoom':
          // Zoom punch - first image zooms out, second zooms in
          const zoomOut = zoom * (1 + progress * 0.3);
          const zoomIn = 1.3 - progress * 0.15;
          drawImage(img1, zoomOut, panX, 1 - progress);
          drawImage(img2, zoomIn, 0, progress);
          break;
          
        case 'slide':
          // Slide - images slide horizontally
          const slideOffset = progress * VIDEO_WIDTH;
          ctx.save();
          ctx.translate(-slideOffset, 0);
          drawImage(img1, zoom, panX, 1);
          ctx.restore();
          ctx.save();
          ctx.translate(VIDEO_WIDTH - slideOffset, 0);
          drawImage(img2, 1.15, 0, 1);
          ctx.restore();
          break;
          
        default:
          drawImage(img1, zoom, panX, 1);
      }
    }
    
    function drawOverlay() {
      const overlayHeight = 200;
      const overlayGradient = ctx.createLinearGradient(0, VIDEO_HEIGHT - overlayHeight, 0, VIDEO_HEIGHT);
      overlayGradient.addColorStop(0, 'rgba(0,0,0,0)');
      overlayGradient.addColorStop(0.5, 'rgba(0,0,0,0.7)');
      overlayGradient.addColorStop(1, 'rgba(0,0,0,0.9)');
      ctx.fillStyle = overlayGradient;
      ctx.fillRect(0, VIDEO_HEIGHT - overlayHeight, VIDEO_WIDTH, overlayHeight);
      
      // Address
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 48px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      const address = propertyData.address || 'Beautiful Property';
      ctx.fillText(address.substring(0, 30), VIDEO_WIDTH / 2, VIDEO_HEIGHT - 100);
      
      // Price and size
      ctx.font = '36px -apple-system, sans-serif';
      ctx.fillStyle = '#ccc';
      const details = [propertyData.price, propertyData.size].filter(Boolean).join(' ‚Ä¢ ');
      ctx.fillText(details, VIDEO_WIDTH / 2, VIDEO_HEIGHT - 50);
    }
    
    function togglePreview() {
      if (isPlaying) {
        stopPreview();
      } else {
        startPreview();
      }
    }
    
    function startPreview() {
      if (images.length === 0) return;
      
      const settings = getSettings();
      const totalFrames = settings.duration * FPS;
      
      isPlaying = true;
      currentFrame = 0;
      document.getElementById('play-btn').textContent = '‚è∏ Pause';
      bgMusic.currentTime = 0;
      bgMusic.volume = 0.3;
      bgMusic.play().catch(() => {});
      
      let lastTime = 0;
      const frameInterval = 1000 / FPS;
      
      function animateThrottled(timestamp) {
        if (!isPlaying) return;
        
        const delta = timestamp - lastTime;
        if (delta >= frameInterval) {
          lastTime = timestamp - (delta % frameInterval);
          drawFrame(currentFrame);
          currentFrame = (currentFrame + 1) % totalFrames;
        }
        
        animationId = requestAnimationFrame(animateThrottled);
      }
      
      animationId = requestAnimationFrame(animateThrottled);
    }
    
    function stopPreview() {
      isPlaying = false;
      document.getElementById('play-btn').textContent = '‚ñ∂ Preview';
      bgMusic.pause();
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }
    
    async function generateVideo() {
      if (images.length === 0) {
        showStatus('No images loaded', true);
        return;
      }
      
      const settings = getSettings();
      const totalFrames = settings.duration * FPS;
      
      stopPreview();
      showStatus('Generating video... This may take a minute.', false);
      document.getElementById('generate-btn').disabled = true;
      
      try {
        const stream = canvas.captureStream(FPS);
        
        // Set up audio
        if (!audioContext) {
          audioContext = new AudioContext();
        }
        
        const audioSource = audioContext.createMediaElementSource(bgMusic);
        const audioDestination = audioContext.createMediaStreamDestination();
        audioSource.connect(audioDestination);
        audioSource.connect(audioContext.destination);
        
        const combinedStream = new MediaStream([
          ...stream.getVideoTracks(),
          ...audioDestination.stream.getAudioTracks()
        ]);
        
        const mediaRecorder = new MediaRecorder(combinedStream, {
          mimeType: 'video/webm;codecs=vp9',
          videoBitsPerSecond: 8000000
        });
        
        const chunks = [];
        mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
        
        mediaRecorder.onstop = () => {
          videoBlob = new Blob(chunks, { type: 'video/webm' });
          hideStatus();
          document.getElementById('download-btn').classList.remove('hidden');
          document.getElementById('generate-btn').disabled = false;
          showStatus('Video ready! Click Download to save.', false);
          bgMusic.pause();
          audioSource.disconnect();
        };
        
        mediaRecorder.start();
        bgMusic.currentTime = 0;
        bgMusic.volume = 0.5;
        bgMusic.play();
        
        let frame = 0;
        const renderInterval = setInterval(() => {
          if (frame >= totalFrames) {
            clearInterval(renderInterval);
            mediaRecorder.stop();
            return;
          }
          
          drawFrame(frame);
          frame++;
          setProgress((frame / totalFrames) * 100);
        }, 1000 / FPS);
        
      } catch (error) {
        console.error('Video generation error:', error);
        showStatus('Video generation failed. Try using Chrome browser.', true);
        document.getElementById('generate-btn').disabled = false;
      }
    }
    
    function downloadVideo() {
      if (!videoBlob) return;
      
      const url = URL.createObjectURL(videoBlob);
      const a = document.createElement('a');
      a.href = url;
      const address = propertyData?.address?.replace(/[^a-zA-Z0-9]/g, '-') || 'property';
      a.download = `etuovi-${address.substring(0, 30)}-${Date.now()}.webm`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function showStatus(text, isError) {
      const status = document.getElementById('status');
      status.classList.remove('hidden');
      status.classList.toggle('error', isError);
      document.getElementById('status-text').textContent = text;
    }
    
    function hideStatus() {
      document.getElementById('status').classList.add('hidden');
    }
    
    function setProgress(percent) {
      document.getElementById('progress-fill').style.width = percent + '%';
    }
    
    // Update preview when settings change
    document.getElementById('bpm-input').addEventListener('change', () => {
      if (images.length > 0) drawFrame(currentFrame);
    });
    document.getElementById('duration-input').addEventListener('change', () => {
      if (images.length > 0) drawFrame(currentFrame);
    });
    document.getElementById('beats-per-image').addEventListener('change', () => {
      if (images.length > 0) drawFrame(currentFrame);
    });
  </script>
</body>
</html>
